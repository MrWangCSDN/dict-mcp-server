# 字典缓存机制说明

## 缓存架构

### 双缓存策略

```
┌─────────────────────────────────────────────┐
│  客户端请求（查询字段）                        │
└─────────────────┬───────────────────────────┘
                  ↓
         ┌────────────────────┐
         │   DictService      │
         │   (优先读取缓存)    │
         └────────┬───────────┘
                  ↓
         ┌────────────────────┐
         │  volatile Map      │  ← 当前缓存（缓存 A）
         │  fieldCache        │  ← 线程安全，可见性保证
         └────────────────────┘
                  ↑
                  │ 原子性切换
                  │
         ┌────────────────────┐
         │  临时 Map          │  ← 新加载的数据（缓存 B）
         │  newCache          │  ← 解析完成后切换
         └────────┬───────────┘
                  ↑
         ┌────────────────────┐
         │  定时刷新任务       │  ← 每 20 秒执行
         │  (后台线程)        │  ← 不阻塞查询
         └────────────────────┘
```

## 缓存保护机制

### 1. 并发控制

使用 `AtomicBoolean isLoading` 防止并发加载：

```java
if (!isLoading.compareAndSet(false, true)) {
    log.debug("字典正在加载中，跳过本次刷新");
    return;
}
```

**效果**：
- 同一时间只有一个加载任务
- 避免重复加载浪费资源
- 避免 GitLab API 并发请求

### 2. 双缓存无锁切换

```java
// 加载到临时缓存
Map<String, FieldDefinition> newCache = schemaParser.parseSchema(xmlStream);

// 原子性切换（单条指令，线程安全）
fieldCache = newCache;
```

**优势**：
- 查询操作无锁，性能极高
- 切换瞬间完成（纳秒级）
- 客户端感知不到切换过程

### 3. 故障保护

```java
try {
    // 加载新数据
    newCache = loadFromGitLab();
    // 切换缓存
    fieldCache = newCache;
    consecutiveFailures.set(0);  // 重置失败计数
} catch (Exception e) {
    // 加载失败，保留旧缓存
    log.error("刷新失败，保留旧缓存继续服务");
    consecutiveFailures.incrementAndGet();
}
```

**保护级别**：

| 连续失败次数 | 处理措施 |
|------------|---------|
| 1-4 次 | 记录错误日志，保留旧缓存 |
| 5-9 次 | 发出警告，保留旧缓存 |
| 10+ 次 | 暂停定时刷新，保留旧缓存 |

### 4. 查询优先级

**客户端请求流程**：

```
客户端查询 → 直接访问 fieldCache（Map）
            ↓
         O(1) 查找
            ↓
         返回结果（毫秒级）
```

**特点**：
- 查询不受加载影响
- 即使正在刷新，查询仍使用旧缓存
- 无需等待，立即响应

## 性能指标

### 查询性能

- **时间复杂度**：O(1)
- **响应时间**：< 1 ms
- **并发能力**：10000+ QPS
- **内存占用**：约 10-50 MB（取决于字段数量）

### 刷新性能

- **首次加载**：2-5 秒（网络 + 解析）
- **定时刷新**：1-3 秒（缓存 GitLab 连接）
- **切换时间**：< 1 纳秒（指针切换）
- **对查询影响**：0（完全无影响）

## 线程安全保证

### volatile 关键字

```java
private volatile Map<String, FieldDefinition> fieldCache;
```

**作用**：
- 保证多线程可见性
- 禁止指令重排序
- 确保切换后所有线程立即看到新缓存

### AtomicBoolean 原子操作

```java
private final AtomicBoolean isLoading = new AtomicBoolean(false);

if (!isLoading.compareAndSet(false, true)) {
    return;  // 已有线程在加载
}
```

**作用**：
- CAS（Compare-And-Swap）原子操作
- 无锁并发控制
- 防止重复加载

## 监控指标

### 刷新状态查询

通过 MCP 工具或 API 查询：

```json
{
  "enabled": true,
  "loading": false,
  "lastSuccessTime": 1676123456789,
  "consecutiveFailures": 0,
  "refreshInterval": 20000
}
```

### 缓存统计

```json
{
  "totalFields": 1523,
  "loaderType": "GitLab Repository",
  "connectionStatus": "connected"
}
```

## 故障场景与应对

### 场景 1：GitLab 临时不可用

**表现**：
- 定时刷新失败
- 客户端查询正常（使用旧缓存）

**处理**：
- 自动重试（每 20 秒）
- 连续失败 5 次发警告
- 连续失败 10 次暂停刷新

### 场景 2：网络波动

**表现**：
- 偶尔刷新失败

**处理**：
- 保留旧缓存
- 下次刷新继续尝试
- 不影响客户端查询

### 场景 3：GitLab 文件损坏

**表现**：
- XML 解析失败

**处理**：
- 保留旧缓存
- 记录详细错误日志
- 等待下次刷新（文件修复后自动恢复）

### 场景 4：高并发查询 + 刷新

**表现**：
- 1000 个客户端同时查询
- 后台正在刷新

**处理**：
- 查询访问旧缓存（不等待）
- 刷新在后台进行（不阻塞）
- 切换瞬间完成（< 1 纳秒）
- 客户端无感知

## 配置建议

### 开发环境

```yaml
dict:
  refresh:
    enabled: true
    interval: 10000  # 10 秒，快速更新
```

### 生产环境

```yaml
dict:
  refresh:
    enabled: true
    interval: 60000  # 60 秒，减少 GitLab 压力
```

### 高可用环境

```yaml
dict:
  refresh:
    enabled: true
    interval: 30000  # 30 秒，平衡更新速度和稳定性
```

## 手动刷新

如果需要立即刷新字典（不等待定时任务），可以：

1. 通过 Actuator 端点触发（需要额外开发）
2. 通过 MCP 工具触发（需要额外开发）
3. 重启服务

## 对比 Maven 加载器

| 特性 | GitLab 加载器 | Maven 加载器 |
|------|-------------|-------------|
| 定时刷新 | ✅ 支持（20 秒） | ❌ 不支持 |
| 热更新 | ✅ 无需重启 | ❌ 需要重启 |
| 缓存策略 | 双缓存（无锁） | 单缓存 |
| 离线可用 | ❌ 需要网络 | ✅ 离线可用 |
| 响应速度 | < 1 ms（缓存） | < 1 ms（缓存） |
| 更新延迟 | 0-20 秒 | 需要重启 |

## 总结

**GitLab 加载器 + 定时刷新**适合以下场景：

✅ 字典文件频繁更新  
✅ 需要多服务实例同步  
✅ 希望零停机更新  
✅ 有稳定的 GitLab 网络连接  

**关键优势**：

- 查询性能不受影响（优先访问缓存）
- 刷新完全后台化（不阻塞客户端）
- 故障自动恢复（保留旧缓存）
- 线程安全无锁设计（高并发友好）
